---
description: Analyze dependencies and plan execution order for open issues
---

# Map Issues

Analyze all open issues to detect dependencies, determine optimal execution order, and output a plan with parallel tracks.

## Usage

```
/ke:map [issue-numbers] [--milestone <name>] [--label <label>] [--json]
```

- With no arguments, analyzes all open issues
- With issue numbers (e.g., `/ke:map 42 45 47`), analyzes only those issues
- Use `--milestone <name>` to filter to a specific milestone (e.g., `--milestone "Sprint 1"`)
- Use `--label <label>` to filter to specific labels (e.g., `--label bug`)
- Use `--json` to output machine-readable JSON (writes to `ke-batch-plan.json`)
- Filters can be combined: `/ke:map --milestone "Sprint 1" --label bug --json`

## Instructions

You are tasked with analyzing open issues to detect dependencies, write them to GitHub, and output an execution plan.

### Step 1: Gather Issues

**Parse arguments:**
1. Extract `--milestone <name>` flag if present (value may be quoted, e.g., `"Sprint 1"`)
2. Extract `--label <label>` flag if present
3. Extract `--json` flag if present (enables machine-readable output)
4. Remaining arguments are treated as issue numbers

**If `--milestone` is provided** (e.g., `/ke:map --milestone "Sprint 1"`):
```bash
# Fetch all open issues in that milestone (optionally filtered by label)
gh issue list --state open --milestone "Sprint 1" [--label "bug"] --json number,title,body,labels,milestone --limit 100
```

**If specific issue numbers are provided** (e.g., `/ke:map 42 45 47`):
```bash
# Fetch each specified issue
gh issue view 42 --json number,title,body,labels,milestone
gh issue view 45 --json number,title,body,labels,milestone
gh issue view 47 --json number,title,body,labels,milestone
```

**If `--milestone` AND issue numbers are both provided** (e.g., `/ke:map 42 45 --milestone "Sprint 1"`):
- Fetch the specified issues
- Verify they belong to the specified milestone (warn if any do not)

**If no arguments or only `--label` provided**, fetch all open issues:
```bash
# All open issues (optionally filtered by label)
gh issue list --state open [--label "bug"] --json number,title,body,labels,milestone --limit 100
```

For each issue, also fetch comments to find implementation plans:
```bash
gh issue view <number> --comments
```

### Step 2: Extract Information from Each Issue

For each issue, extract:

1. **Explicit dependencies** - Look for `**Depends on:** #X` in body or comments
2. **Files to be modified** - From the "Files to Modify" section of implementation plans
3. **Complexity estimate** - Based on number of files and steps in plan
4. **Existing worktree status** - Check if already in progress (`git worktree list`)

Issues without implementation plans should be flagged as "unplanned."

### Step 3: Detect New Dependencies

Analyze for dependencies that aren't explicitly declared:

**File overlap detection:**
- If issue A and issue B both modify `src/auth/middleware.ts`, they likely depend on each other
- The one with fewer changes or simpler scope should go first
- Add dependency: the more complex one depends on the simpler one

**Component overlap detection:**
- Issues touching the same component/directory (e.g., both in `src/auth/`)
- May benefit from sequential work to establish patterns

**Merge risk assessment:**
- Issues touching many of the same files = high merge risk if parallel
- Prefer sequential execution for high-overlap pairs

**Criteria for NOT adding a dependency:**
- Issues touch completely different parts of the codebase
- File overlap is trivial (e.g., both add to a config file)
- One issue is clearly independent (e.g., documentation only)

### Step 4: Apply Dependencies to Issues

For each newly detected dependency, update the issue on GitHub:

```bash
gh issue comment <number> --body "**Depends on:** #<dependency-number>

_Detected by /ke:map: Both issues modify \`src/auth/middleware.ts\`. Sequential execution recommended to avoid merge conflicts._

---
*Generated by Claude Code*"
```

**Important:**
- Only add NEW dependencies (don't duplicate existing ones)
- Include a brief explanation of why the dependency was detected
- This creates a persistent record on GitHub that future runs will read

### Step 5: Build Dependency Graph

Create a directed graph where:
- Nodes = issues
- Edges = dependencies (A → B means "A must complete before B")

Identify:
- **Root nodes** - Issues with no dependencies (can start immediately)
- **Leaf nodes** - Issues that nothing depends on
- **Chains** - Linear sequences of dependencies
- **Parallel groups** - Issues that can run simultaneously

### Step 6: Build Dependency Trees

Organize issues into dependency trees for the output:

**Tree construction rules:**
1. **Root nodes:** Issues with no dependencies become tree roots (can start immediately)
2. **Child nodes:** Issues that depend on others become children of their dependencies
3. **Grouping:** Issues at the same level with no file overlap can be combined on one line (processed sequentially in one worktree)
4. **Branching:** When two issues both depend on the same parent but conflict with each other (file overlap), they become separate branches
5. **Separate trees:** Fully independent issue groups become separate trees (each tree = one terminal, trees run in parallel)

**Ordering within trees:**
1. Dependency order (parent before child)
2. Complexity (simpler issues first when grouping)
3. Risk (lower risk first when grouping)

### Step 7: Output the Plan

**If `--json` flag is present**, skip to Step 7b for JSON output.

**Otherwise**, generate the human-readable output below:

#### Section 1: Dependency Updates Applied

```markdown
## Dependencies Applied

| Issue | New Dependency | Reason |
|-------|---------------|--------|
| #45 | Depends on #42 | Both modify src/auth/middleware.ts |
| #47 | Depends on #42 | Both modify src/auth/middleware.ts |
| #51 | Depends on #50 | Both modify src/components/Button.tsx |

3 dependencies added to issues.
```

If no new dependencies were found:
```markdown
## Dependencies

No new dependencies detected. Existing dependencies are up to date.
```

#### Section 2: Execution Plan

Output an ASCII dependency tree using box-drawing characters. The tree structure shows:
- **Root level (no indent):** Issues that can start immediately
- **Child level (indented with └──):** Issues that depend on the parent completing
- **Multiple issues on one line:** Grouped for sequential processing in one worktree (no file overlap between them)
- **Separate trees:** Fully independent tracks — each tree runs in its own terminal (true parallelism)

**Example output:**

```markdown
## Execution Plan

```
/ke:branchfix 42 43 44
│
├── /ke:branchfix 45 46         # 45←42, 46←43 (grouped - no file overlap, runs sequentially)
│       │
│       └── /ke:branchfix 47    # ←45
│               │
│               └── /ke:branchfix 48    # ←47
│
└── /ke:branchfix 49            # ←44 (file conflict with 45, separate branch)
        │
        └── /ke:branchfix 50    # ←49


/ke:branchfix 51
│
└── /ke:branchfix 52            # ←51
        │
        └── /ke:branchfix 53    # ←52
```

**Reading the tree:**
- Each tree runs in its own terminal (2 trees = 2 parallel terminals)
- `/ke:branchfix 42 43 44` processes issues **sequentially** in ONE terminal (42 → 43 → 44, same worktree)
- `/ke:branchfix 51` runs in a SEPARATE terminal (parallel with the first tree)
- `45 46` are grouped because 45 needs 42 and 46 needs 43 (both satisfied by parent), and they don't share files
- `49` is a separate branch from `45 46` because they conflict on `src/auth/middleware.ts`

**Parallelism vs Sequential:**
- **Parallel:** Separate trees run in separate terminals simultaneously
- **Sequential:** Issues within a single `/ke:branchfix` command run one after another in the same worktree

**Grouping rules applied:**
- Issues grouped on one line when: no explicit dependency between them AND no file overlap
- Grouped issues share a worktree and are processed sequentially (not in parallel)
- File conflicts force separate branches even without explicit dependencies
```

**Formatting rules:**
1. Use `│`, `├──`, and `└──` box-drawing characters
2. Group issues on one line when they have no file overlap and their dependencies are all satisfied by the same parent (they will run sequentially in one worktree)
3. Add brief comments showing dependency arrows (e.g., `# 45←42, 46←43`)
4. Note file conflicts when they force branching (e.g., `# file conflict with 45`)
5. Separate independent trees with a blank line
6. After the tree, include a "Reading the tree" section explaining the grouping decisions

#### Section 3: Additional Information

After the tree, include these sections if applicable:

```markdown
### Blocked
| Issue | Blocked By | Reason |
|-------|-----------|--------|
| #48 | #45 | Explicit dependency in issue |

### Unplanned (run /ke:plan first)
- #52: No implementation plan found
- #56: No implementation plan found
```

### Step 7b: JSON Output (when `--json` flag is present)

Instead of the ASCII tree, output a machine-readable JSON structure and write it to `ke-batch-plan.json` in the repository root.

**JSON Schema:**

```json
{
  "version": 1,
  "timestamp": "2026-01-22T10:00:00Z",
  "repository": "owner/repo",
  "base_branch": "main",
  "tracks": [
    {
      "id": "A",
      "name": "Auth System",
      "description": "Issues with shared files in src/auth/",
      "issues": [
        {
          "number": 42,
          "title": "Add auth middleware",
          "depends_on": [],
          "files": ["src/auth/middleware.ts"],
          "has_plan": true,
          "in_progress": false
        },
        {
          "number": 45,
          "title": "Add login endpoint",
          "depends_on": [42],
          "files": ["src/auth/middleware.ts", "src/auth/login.ts"],
          "has_plan": true,
          "in_progress": false
        }
      ]
    },
    {
      "id": "B",
      "name": "Independent",
      "description": "No file overlap with other issues",
      "issues": [
        {
          "number": 51,
          "title": "Fix typo in README",
          "depends_on": [],
          "files": ["README.md"],
          "has_plan": true,
          "in_progress": false
        }
      ]
    }
  ],
  "blocked": [
    {
      "number": 48,
      "title": "Blocked issue title",
      "blocked_by": [45],
      "reason": "Explicit dependency in issue"
    }
  ],
  "unplanned": [52, 56],
  "in_progress": [
    {
      "number": 42,
      "worktree": "../repo-issue-42",
      "branch": "issue-42",
      "uncommitted_files": 3
    }
  ]
}
```

**Field definitions:**

- `version`: Schema version (always 1 for now)
- `timestamp`: ISO 8601 timestamp when the plan was generated
- `repository`: GitHub owner/repo identifier
- `base_branch`: The branch all root issues should branch from (usually "main")
- `tracks`: Array of parallel execution tracks (issues within a track are sequential)
  - `id`: Single letter identifier (A, B, C, ...)
  - `name`: Human-readable track name
  - `description`: Why these issues are grouped together
  - `issues`: Ordered array of issues in this track (execute in order)
    - `number`: GitHub issue number
    - `title`: Issue title
    - `depends_on`: Array of issue numbers this issue depends on
    - `files`: Array of file paths this issue will modify
    - `has_plan`: Whether an implementation plan exists
    - `in_progress`: Whether a worktree already exists
- `blocked`: Issues that cannot be scheduled (external blockers, etc.)
- `unplanned`: Issue numbers that lack implementation plans
- `in_progress`: Issues with existing worktrees

**Track construction:**
- Each track represents a chain of dependent issues
- Issues within a track are ordered by dependency (parent before child)
- Parallel tracks have no file overlap between them
- The orchestrator can run tracks in parallel terminals

**Write the file:**
```bash
# Write JSON to file (use cat with heredoc for proper formatting)
cat > ke-batch-plan.json << 'EOF'
{
  "version": 1,
  ...
}
EOF
```

**Also display a summary:**
```markdown
## Batch Plan Generated

Written to `ke-batch-plan.json`

**Tracks:** 2
- Track A (Auth System): #42 → #45 → #47
- Track B (Independent): #51

**Issues:** 4 planned, 2 unplanned, 1 blocked

Use `/ke:batch` to execute this plan automatically.
```

### Step 8: Handle Edge Cases

**No open issues:**
```
No open issues found. Nothing to map.
```

**All issues are independent:**
```
All 5 issues are independent with no file overlap.
Run them in any order, or process sequentially in one worktree with: /ke:branchfix 42 43 44 45 46
```

**Circular dependencies detected:**
```
Warning: Circular dependency detected: #42 → #45 → #47 → #42
Please review and resolve manually. Skipping these issues from the plan.
```

**Issues already in progress:**
Include them in the plan but mark their status:
```
### In Progress (from /ke:status)
- #42: Worktree exists at ../repo-issue-42 (3 uncommitted files)
```

### Important

- DO NOT implement any code changes
- DO NOT create or modify files (except GitHub issue comments for dependencies, and `ke-batch-plan.json` when using `--json`)
- If an issue lacks a plan, suggest running `/ke:plan` first
- Detected dependencies are written to issues to create a persistent source of truth
- Re-running `/ke:map` will read existing dependencies and only add new ones
- When using `--json`, the plan file can be used by `/ke:batch` for automated execution
